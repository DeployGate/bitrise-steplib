format_version: 1.1.0
default_step_lib_source: https://github.com/bitrise-io/bitrise-steplib.git

app:
  envs:
  - STEPLIB_SOURCE: 'https://github.com/bitrise-io/bitrise-steplib.git'
  # define these ENVs in your .bitrise.secrets.yml
  - AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
  - AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
  - S3_UPLOAD_BUCKET: $S3_UPLOAD_BUCKET
  - S3_UPLOAD_BUCKET_REGION: $S3_UPLOAD_BUCKET_REGION

workflows:
  test_handlers:
    steps:
    - path::./handler/audit:

  pr_audit:
    title: Pull Request audit
    description: |-
      Performs an audit only on the changed step.yml files, and on the
      related Steps.
    steps:
    - path::./handler/step-info:
    - path::./handler/generate-specs:
    - path::./handler/audit:

  full_audit:
    title: Full Audit
    description: |-
      Performs a full audit on the collection.
    steps:
    - script:
        title: Run full audit on the StepLib collection
        inputs:
        - content: |-
            #!/bin/bash

            stepman audit --collection "${TMP_COLLECTION_ID}"

  deploy:
    title: Workflow for deployment
    description: |-
      Deploys the StepLib to Amazon S3
    before_run:
    - full_audit
    steps:
    - script:
        inputs:
        - content: |-
            #!/bin/bash

            echo "test"

  # _generate:
  #   title: Workflow for testing, PR check
  #   description: |-
  #     Adds a clean copy of this StepLib collection to stepman,
  #     calls a setup on it, moves the generated spec.json to
  #     a specified path and makes the path available for other workflows.
  #   steps:
  #   - script:
  #       title: Set TMP_COLLECTION_ID
  #       inputs:
  #       - content: |-
  #           #!/bin/bash
  #           set -ex
            
  #           envman add --key TMP_COLLECTION_ID --value "file://$(pwd)"
  #   - script:
  #       title: Remove previous version of this local spec from stepman
  #       inputs:
  #       - content: |-
  #           #!/bin/bash
  #           set -ex
            
  #           stepman delete -c "${TMP_COLLECTION_ID}"
  #   - script:
  #       title: Generate
  #       dependencies:
  #         - manager: brew
  #           name: jq
  #       inputs:
  #       - content: |-
  #           #!/bin/bash
  #           set -ex

  #           tmp_dir="$(pwd)/_tmp"
  #           mkdir -p "${tmp_dir}"
  #           spec_path="${tmp_dir}/spec.json"
  #           stepman setup -c "${TMP_COLLECTION_ID}" --copy-spec-json="${spec_path}"
  #           slim_spec_path="$(find "${HOME}/.stepman" -name slim-spec.json | head -n1)"
  #           # write out minimized slim-spec.json
  #           jq --compact-output '.' ${slim_spec_path} > "${tmp_dir}/slim-spec.json"
  #           envman add --key SPEC_JSON_PATH --value "${spec_path}"
  #           envman add --key SLIM_JSON_PATH --value "${spec_path/spec.json/slim-spec.json}"
  #   - script:
  #       title: tmp
  #       inputs:
  #       - content: |-
  #           #!/bin/bash
  #           set -e

  #           echo "SPEC_JSON_PATH: ${SPEC_JSON_PATH}"
  #           echo "SLIM_JSON_PATH: ${SLIM_JSON_PATH}"

  # pr_audit:
  #   title: Pull Request audit
  #   description: |-
  #     Performs an audit only on the changed step.yml files, and on the
  #     related Steps.

  #     Development Note: if `IS_LOCAL_TEST` is enabled it'll check the
  #     changes in the local git staging/cache.
  #   envs:
  #     - BITRISE_WORKFLOW_ID: pr_audit
  #   before_run:
  #   - _generate
  #   after_run:
  #   - _notifications
  #   steps:
  #   - script:
  #       title: List of changed files
  #       dependencies:
  #       - manager: brew
  #         name: go
  #       inputs:
  #       - content: |-
  #           set -e
  #           localtest_param=""
  #           if [[ "${IS_LOCAL_TEST}" == "true" ]] ; then
  #             localtest_param="--localtest"
  #           fi

  #           go get github.com/hashicorp/go-version
  #           go get github.com/bitrise-io/go-utils/command
  #           go get github.com/bitrise-io/go-utils/fileutil
  #           go get github.com/bitrise-io/go-utils/pathutil
  #           go get github.com/bitrise-io/go-utils/log
  #           go get gopkg.in/yaml.v2

  #           go run ./_scripts/audit/audit_changed_steps.go --collectionid "${TMP_COLLECTION_ID}" ${localtest_param}
  #   - script:
  #       title: Check icon for the changes steps
  #       dependencies:
  #       - manager: brew
  #         name: go
  #       inputs:
  #       - content: |-
  #           set -e
            
  #           go get github.com/hashicorp/go-version
  #           go get github.com/bitrise-io/go-utils/command
  #           go get github.com/bitrise-io/go-utils/fileutil
  #           go get github.com/bitrise-io/go-utils/pathutil
  #           go get github.com/bitrise-io/go-utils/log
  #           go get gopkg.in/yaml.v2

  #           go run ./_scripts/audit_icons/audit_icons.go --collectionid "${TMP_COLLECTION_ID}" ${localtest_param}

  # full_audit:
  #   title: Full Audit
  #   description: |-
  #     Performs a full audit on the collection.
  #   before_run:
  #   - _generate
  #   steps:
  #   - script:
  #       title: Run full audit on the StepLib collection
  #       inputs:
  #       - content: |-
  #           set -ex

  #           stepman audit --collection "${TMP_COLLECTION_ID}"

  # deploy:
  #   title: Workflow for deployment
  #   description: |-
  #     Deploys the StepLib to Amazon S3
  #   envs:
  #     - AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
  #     - AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
  #     - S3_UPLOAD_BUCKET_REGION: $S3_UPLOAD_BUCKET_REGION
  #     - S3_UPLOAD_BUCKET: $S3_UPLOAD_BUCKET
  #     - BITRISE_WORKFLOW_ID: "DEPLOY"
  #   before_run:
  #   - full_audit
  #   after_run:
  #   - _notifications
  #   steps:
  #   - script:
  #       title: Check spec.json - exist?
  #       inputs:
  #       - content: |-
  #           #!/usr/bin/env bash
  #           if [[ ! -f "${SPEC_JSON_PATH}" ]] ; then
  #             echo " [!] spec.json does not exist at path: ${SPEC_JSON_PATH}"
  #             exit 1
  #           fi
  #           if [[ ! -f "${SLIM_JSON_PATH}" ]] ; then
  #             echo " [!] slim-spec.json does not exist at path: ${SLIM_JSON_PATH}"
  #             exit 1
  #           fi
  #   - script:
  #       title: Fix steplib_source in spec.json
  #       inputs:
  #       - content: |-
  #           require 'json'

  #           spec_json_pth = ENV['SPEC_JSON_PATH']
  #           puts " -> spec_json_pth: #{spec_json_pth}"
  #           file = File.read(spec_json_pth)
  #           data_hash = JSON.parse(file)

  #           puts " -> original steplib source: #{data_hash['steplib_source']}"
  #           steplib_source_param = ENV['STEPLIB_SOURCE']
  #           puts " -> steplib_source_param: #{steplib_source_param}"
  #           data_hash['steplib_source'] = steplib_source_param
  #           File.write(spec_json_pth, JSON.pretty_generate(data_hash))
  #           puts "DONE - OK"
  #       - runner_bin: ruby
  #   - script:
  #       title: Generate
  #       dependencies:
  #         - manager: brew
  #           name: s3cmd
  #       inputs:
  #       - content: |-
  #           #!/bin/bash
  #           set -ex

  #           bash ./_scripts/deploy/deploy.sh

  #   - script:
  #       title: Upload slim.json
  #       dependencies:
  #         - manager: brew
  #           name: awscli
  #       inputs:
  #       - content: |-
  #           #!/usr/bin/env bash
  #           set -ex

  #           aws s3 cp "${SLIM_JSON_PATH}" "s3://${S3_UPLOAD_BUCKET}/slim-spec.json" --acl public-read
  #           aws s3 cp "${SLIM_JSON_PATH}" "s3://${S3_UPLOAD_BUCKET}/slim-spec.json.gz" --acl public-read --content-encoding gzip

